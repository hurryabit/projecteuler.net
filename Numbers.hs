-- | Library for some number theoretic funtions.
module Numbers
  ( module Numbers
  , primes)
  where

import Data.Array.IArray
import Data.Bits
import Data.Function
import Data.List
import Data.Numbers.Primes (primes)

-- | List of all primes contained in an array generated by 'isPrimeArray'.
primesFrom :: Array Int Bool -> [Int]
primesFrom pa = [ p | (p,True) <- assocs pa ]

isPrime :: Integral a => a -> Bool
isPrime = isPrimeBy primes

{-# SPECIALIZE isPrime :: Int     -> Bool #-}
{-# SPECIALIZE isPrime :: Integer -> Bool #-}

-- | Given an ascending list of primes isPrimeBy checks for a number n if it
--   has no divisors below the square root of n in the list.
isPrimeBy :: Integral a => [a] -> a -> Bool
isPrimeBy ps 1 = False
isPrimeBy ps n = all (\p -> p `notDivides` n) $ takeWhile (\p -> p*p<=n) ps

{-# SPECIALIZE isPrimeBy :: [Int]     -> Int     -> Bool #-}
{-# SPECIALIZE isPrimeBy :: [Integer] -> Integer -> Bool #-}

-- | Returns an array where for each k from 1 to n is stored whether k is prime.
isPrimeArray :: Int -> Array Int Bool
isPrimeArray n =  let pa  = array (1,n) $ [(1,False),(2,True)] ++
                            [(k,False) | k <- [4,6..n]] ++
                            [(k,isPrimeBy ps k) | k <- [3,5..n]]
                      ps  = primesFrom pa
                  in  pa

-- | Given a natural number n returns the factorization of n as a list
--   [(p1,e1),(p2,e2),...,(pk,ek)] with p1<p2<...<pk and 
--   k = p1^e1*p2^e2*...*pk^ek.
factorization :: (Integral a,Integral e) => a -> [(a,e)]
factorization = factorizationBy primes

{-# SPECIALIZE factorization :: Int     -> [(Int    ,Int)] #-}
{-# SPECIALIZE factorization :: Integer -> [(Integer,Int)] #-}

factorizationBy :: (Integral a, Integral e) => [a] -> a -> [(a,e)]
factorizationBy = foldFactorizationBy factorizationFF

{-# SPECIALIZE factorizationBy :: [Int]     -> Int     -> [(Int    ,Int)] #-}
{-# SPECIALIZE factorizationBy :: [Integer] -> Integer -> [(Integer,Int)] #-}

factorizationArray :: Int -> Array Int [(Int,Int)]
factorizationArray = foldFactorizationArray factorizationFF

-- | Given a natural number n returns an unordered list of all divisores of n.
divisors :: Integral a => a -> [a]
divisors = divisorsBy primes

{-# SPECIALIZE divisors :: Int     -> [Int    ] #-}
{-# SPECIALIZE divisors :: Integer -> [Integer] #-}

divisorsBy :: Integral a => [a] -> a -> [a]
divisorsBy = foldFactorizationBy divisorsFF

{-# SPECIALIZE divisorsBy :: [Int]     -> Int     -> [Int    ] #-}
{-# SPECIALIZE divisorsBy :: [Integer] -> Integer -> [Integer] #-}

divisorsArray :: Int -> Array Int [Int]
divisorsArray = foldFactorizationArray divisorsFF

-- | Given a natural number n return the number of all divisors of n.
numDivisors :: Integral a => a -> Int
numDivisors = numDivisorsBy primes

{-# SPECIALIZE numDivisors :: Int     -> Int #-}
{-# SPECIALIZE numDivisors :: Integer -> Int #-}

numDivisorsBy :: Integral a => [a] -> a -> Int
numDivisorsBy = foldFactorizationBy numDivisorsFF

{-# SPECIALIZE numDivisorsBy :: [Int]     -> Int     -> Int #-}
{-# SPECIALIZE numDivisorsBy :: [Integer] -> Integer -> Int #-}

numDivisorsArray :: Int -> Array Int Int
numDivisorsArray = foldFactorizationArray numDivisorsFF

-- | Eulers totient function.
phi :: Integral a => a -> a
phi = phiBy primes

{-# SPECIALIZE phi :: Int     -> Int     #-}
{-# SPECIALIZE phi :: Integer -> Integer #-}

phiBy :: Integral a => [a] -> a -> a
phiBy = foldFactorizationBy phiFF

{-# SPECIALIZE phiBy :: [Int]     -> Int     -> Int     #-}
{-# SPECIALIZE phiBy :: [Integer] -> Integer -> Integer #-}

phiArray :: Int -> Array Int Int
phiArray = foldFactorizationArray phiFF

-- | m `divides` n checks whether m is a divisor of n.
divides :: Integral a => a -> a -> Bool
m `divides` n = n `mod` m == 0

{-# SPECIALIZE divides :: Int     -> Int     -> Bool #-}
{-# SPECIALIZE divides :: Integer -> Integer -> Bool #-}

-- | m `notDivides` n checks whether m is not a divisor of n.
notDivides :: Integral a => a -> a -> Bool
m `notDivides` n = n `mod` m /= 0

{-# SPECIALIZE notDivides :: Int     -> Int     -> Bool #-}
{-# SPECIALIZE notDivides :: Integer -> Integer -> Bool #-}

-- | divMaxPow n m finds the greatest power m^k that divides n an returns
--   n/m^k and k.
divMaxPow :: (Integral a, Integral e) => a -> a -> (a,e)
divMaxPow n m = divMaxPow' 0 n
  where divMaxPow' k n = case n `divMod` m of
          (q,0) -> divMaxPow' (k+1) q
          (q,_) -> (n,k)

{-# SPECIALIZE divMaxPow :: Int     -> Int     -> (Int    ,Int) #-}
{-# SPECIALIZE divMaxPow :: Integer -> Integer -> (Integer,Int) #-}

-- | powMod x k m = x^k `mod` m
powMod :: (Integral a, Integral e, Bits e) => a -> e -> a -> a
powMod x k m =
  let run x k y
        | k' == 0   = y'
        | otherwise = run x' k' y'
        where k' = k `shiftR` 1
              x' = x*x `mod` m
              y' = if k `testBit` 0 then x*y `mod` m else y
  in  run x k 1

{-# SPECIALIZE powMod :: Int     -> Int -> Int     -> Int     #-}
{-# SPECIALIZE powMod :: Integer -> Int -> Integer -> Integer #-}

-- | Returns a list of the digits for a given natural number the least
--   significant digit first.
digits :: Integral a => a -> [a]
digits = unfoldr f
  where f 0 = Nothing
        f n = let (q,r) = n `divMod` 10 in Just (r,q)

-- | Inverse of digits.
foldDigits :: Integral a => [a] -> a
foldDigits = foldr (\d n -> 10*n+d) 0

-- | Digit sum of a natural number.
digitSum :: Integral a => a -> a
digitSum = sum . digits

-- | Reverses a number by reversing the sequence of its digits
reverseNum :: Integral a => a -> a
reverseNum = foldl (\n d -> 10*n+d) 0 . digits


euclid :: Integral a => a -> a -> (a,a,a)
euclid a b
    | c == 0    = (b,0,1)
    | otherwise = let (d,r,s) = euclid b c
                  in  (d,s,r-s*q)
    where (q,c) = a `divMod` b

{-# SPECIALIZE euclid :: Int     -> Int     -> (Int    ,Int    ,Int    ) #-}
{-# SPECIALIZE euclid :: Integer -> Integer -> (Integer,Integer,Integer) #-}

chinese2 :: Integral a => (a,a) -> (a,a) -> (a,a)
chinese2 (a,m) (b,n)
    | d == 1 = ((s*n*a+r*m*b) `mod` (m*n),m*n)
    | otherwise = error $
        unwords ["chinese",show (fromIntegral a,fromIntegral m),show (fromIntegral b,fromIntegral n),"not defined!"]
    where (d,r,s) = euclid m n

{-# SPECIALIZE chinese2 :: (Int    ,Int    ) -> (Int    ,Int    ) -> (Int    ,Int    ) #-}
{-# SPECIALIZE chinese2 :: (Integer,Integer) -> (Integer,Integer) -> (Integer,Integer) #-}

chinese :: Integral a => [(a,a)] -> (a,a)
chinese = foldr1 chinese2

{-# SPECIALIZE chinese :: [(Int    ,Int    )] -> (Int    ,Int    ) #-}
{-# SPECIALIZE chinese :: [(Integer,Integer)] -> (Integer,Integer) #-}

data FF a e b = FF
  { start   :: b
  , combine :: a -> e -> b -> b
  }

factorizationFF :: (Integral a, Integral e) => FF a e [(a,e)]
factorizationFF = FF
  { start   = []
  , combine = \p k fs -> (p,k):fs
  }

{-# SPECIALIZE factorizationFF :: FF Int     Int [(Int    ,Int)] #-}
{-# SPECIALIZE factorizationFF :: FF Integer Int [(Integer,Int)] #-}

divisorsFF :: Integral a => FF a Int [a]
divisorsFF = FF
  { start   = [1]
  , combine = \p k ds -> [ pk*d | d <- ds, pk <- take (k+1) (iterate (p*) 1) ]
  }

{-# SPECIALIZE divisorsFF :: FF Int     Int [Int    ] #-}
{-# SPECIALIZE divisorsFF :: FF Integer Int [Integer] #-}

numDivisorsFF :: Integral a => FF a Int Int
numDivisorsFF = FF
  { start   = 1
  , combine = \p k n -> (k+1)*n
  }

{-# SPECIALIZE numDivisorsFF :: FF Int     Int Int #-}
{-# SPECIALIZE numDivisorsFF :: FF Integer Int Int #-}

phiFF :: Integral a => FF a Int a
phiFF = FF
  { start   = 1
  , combine = \p k phy -> (p-1)*p^(k-1)*phy
  }

{-# SPECIALIZE phiFF :: FF Int     Int Int     #-}
{-# SPECIALIZE phiFF :: FF Integer Int Integer #-}

foldFactorizationBy :: (Integral a, Integral e) => FF a e b -> [a] -> a -> b
foldFactorizationBy ff ps = fix $ \f -> foldFactorizationMemoizedBy f ff ps

{-# SPECIALIZE foldFactorizationBy :: FF Int     Int b -> [Int    ] -> Int     -> b #-}
{-# SPECIALIZE foldFactorizationBy :: FF Integer Int b -> [Integer] -> Integer -> b #-}

foldFactorizationMemoizedBy ::
  (Integral a, Integral e) => (a -> b) -> FF a e b -> [a] -> a -> b
foldFactorizationMemoizedBy cb ff = run
  where run _ 1 = start ff
        run (p:ps) m
          | m < p*p   = combine ff m 1 (start ff)
          | otherwise = case divMaxPow m p of
              (q,0) -> run ps m
              (q,k) -> combine ff p k (cb q)

{-# SPECIALIZE foldFactorizationMemoizedBy :: (Int     -> b) -> FF Int     Int b -> [Int    ] -> Int     -> b #-}
{-# SPECIALIZE foldFactorizationMemoizedBy :: (Integer -> b) -> FF Integer Int b -> [Integer] -> Integer -> b #-}

-- | Generalized function to generate the arrays for factorizations, divisors
--   and phi.
--   generateArray start combine prime n generates an array with indices 1 to n.
--   The value for 1 becomes start, the value for each prime p becomes (prime p)
--   and the value for each composite number m=p^k*q where p is the smallest
--   prime divisor of m, k the highest exponent of p in m and q the rest,
--   becomes (comb (p,k) q') where q' is the value for q.
foldFactorizationArray :: FF Int Int a -> Int -> Array Int a
foldFactorizationArray ff n = fix $ \ga -> listArray (1,n) $
  map (foldFactorizationMemoizedBy (ga !) ff primes') [1..n]
  where primes' :: [Int]
        primes' = primes
