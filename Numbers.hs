-- | Library for some number theoretic funtions.
module Numbers where

import Data.Array.IArray
import Data.Function
import Data.List

-- | Lazy list of all primes. Note: this is not a CAF so it won't be memoized.
primes :: Integral a => [a]
primes = fix $ \ps -> 2:filter (isPrimeBy ps) [3,5..]

-- | List of all primes contained in an array generated by 'isPrimeArray'.
primesFrom :: Array Int Bool -> [Int]
primesFrom pa = [ p | (p,True) <- assocs pa ]

isPrime :: Integral a => a -> Bool
isPrime = isPrimeBy primes

-- | Given an ascending list of primes isPrimeBy checks for a number n if it
--   has no divisors below the square root of n in the list.
isPrimeBy :: Integral a => [a] -> a -> Bool
isPrimeBy ps 1 = False
isPrimeBy ps n = all (\p -> p `notDivides` n) $ takeWhile (\p -> p*p<=n) ps

-- | Returns an array where for each k from 1 to n is stored whether k is prime.
isPrimeArray :: Int -> Array Int Bool
isPrimeArray n =  let pa  = array (1,n) $ [(1,False),(2,True)] ++
                            [(k,False) | k <- [4,6..n]] ++
                            [(k,isPrimeBy ps k) | k <- [3,5..n]]
                      ps  = primesFrom pa
                  in  pa

-- | Given a natural number n returns the factorization of n as a list
--   [(p1,e1),(p2,e2),...,(pk,ek)] with p1<p2<...<pk and 
--   k = p1^e1*p2^e2*...*pk^ek.
factorization :: (Integral a,Integral e) => a -> [(a,e)]
factorization = factorizationBy primes

factorizationBy :: (Integral a, Integral e) => [a] -> a -> [(a,e)]
factorizationBy = foldFactorizationBy factorizationFF

factorizationArray :: Int -> Array Int [(Int,Int)]
factorizationArray = foldFactorizationArray factorizationFF

-- | Given a natural number n returns an unordered list of all divisores of n.
divisors :: Integral a => a -> [a]
divisors = divisorsBy primes

divisorsBy :: Integral a => [a] -> a -> [a]
divisorsBy = foldFactorizationBy divisorsFF

divisorsArray :: Int -> Array Int [Int]
divisorsArray = foldFactorizationArray divisorsFF

-- | Given a natural number n return the number of all divisors of n.
numDivisors :: Integral a => a -> Int
numDivisors = numDivisorsBy primes

numDivisorsBy :: Integral a => [a] -> a -> Int
numDivisorsBy = foldFactorizationBy numDivisorsFF

numDivisorsArray :: Int -> Array Int Int
numDivisorsArray = foldFactorizationArray numDivisorsFF

-- | Eulers totient function.
phi :: Integral a => a -> a
phi = phiBy primes

phiBy :: Integral a => [a] -> a -> a
phiBy = foldFactorizationBy phiFF

phiArray :: Int -> Array Int Int
phiArray = foldFactorizationArray phiFF

-- | m `divides` n checks whether m is a divisor of n.
divides :: Integral a => a -> a -> Bool
m `divides` n = n `mod` m == 0

-- | m `notDivides` n checks whether m is not a divisor of n.
notDivides :: Integral a => a -> a -> Bool
m `notDivides` n = n `mod` m /= 0

-- | divMaxPow n m finds the greatest power m^k that divides n an returns
--   n/m^k and k.
divMaxPow :: (Integral a, Integral e) => a -> a -> (a,e)
divMaxPow n m = divMaxPow' 0 n
  where divMaxPow' k n = case n `divMod` m of
          (q,0) -> divMaxPow' (k+1) q
          (q,_) -> (n,k)

-- | Returns a list of the digits for a given natural number the least
--   significant digit first.
digits :: Integral a => a -> [a]
digits = unfoldr f
  where f 0 = Nothing
        f n = let (q,r) = n `divMod` 10 in Just (r,q)

-- | Inverse of digits.
foldDigits :: Integral a => [a] -> a
foldDigits = foldr (\d n -> 10*n+d) 0

-- | Digit sum of a natural number.
digitSum :: Integral a => a -> a
digitSum = sum . digits

-- | Reverses a number by reversing the sequence of its digits
reverseNum :: Integral a => a -> a
reverseNum = foldl (\n d -> 10*n+d) 0 . digits


euclid :: Integral a => a -> a -> (a,a,a)
euclid a b
    | c == 0    = (b,0,1)
    | otherwise = let (d,r,s) = euclid b c
                  in  (d,s,r-s*q)
    where (q,c) = a `divMod` b

chinese2 :: Integral a => (a,a) -> (a,a) -> (a,a)
chinese2 (a,m) (b,n)
    | d == 1 = ((s*n*a+r*m*b) `mod` (m*n),m*n)
    | otherwise = error $
        unwords ["chinese",show (fromIntegral a,fromIntegral m),show (fromIntegral b,fromIntegral n),"not defined!"]
    where (d,r,s) = euclid m n

chinese :: Integral a => [(a,a)] -> (a,a)
chinese = foldr1 chinese2



data FF a e b = FF
  { start   :: b
  , combine :: a -> e -> b -> b
  }

factorizationFF :: FF a e [(a,e)]
factorizationFF = FF
  { start   = []
  , combine = \p k fs -> (p,k):fs
  }

divisorsFF :: Integral a => FF a Int [a]
divisorsFF = FF
  { start   = [1]
  , combine = \p k ds -> [ pk*d | d <- ds, pk <- take (k+1) (iterate (p*) 1) ]
  }

numDivisorsFF :: Integral a => FF a Int Int
numDivisorsFF = FF
  { start   = 1
  , combine = \p k n -> (k+1)*n
  }

phiFF :: Integral a => FF a Int a
phiFF = FF
  { start   = 1
  , combine = \p k phy -> (p-1)*p^(k-1)*phy
  }

foldFactorizationBy :: (Integral a, Integral e) => FF a e b -> [a] -> a -> b
foldFactorizationBy ff ps = fix $ \f -> foldFactorizationMemoizedBy f ff ps

foldFactorizationMemoizedBy ::
  (Integral a, Integral e) => (a -> b) -> FF a e b -> [a] -> a -> b
foldFactorizationMemoizedBy cb ff = run
  where run _ 1 = start ff
        run (p:ps) m
          | m < p*p   = combine ff m 1 (start ff)
          | otherwise = case divMaxPow m p of
              (q,0) -> run ps m
              (q,k) -> combine ff p k (cb q)

-- | Generalized function to generate the arrays for factorizations, divisors
--   and phi.
--   generateArray start combine prime n generates an array with indices 1 to n.
--   The value for 1 becomes start, the value for each prime p becomes (prime p)
--   and the value for each composite number m=p^k*q where p is the smallest
--   prime divisor of m, k the highest exponent of p in m and q the rest,
--   becomes (comb (p,k) q') where q' is the value for q.
foldFactorizationArray :: FF Int Int a -> Int -> Array Int a
foldFactorizationArray ff n = fix $ \ga -> listArray (1,n) $
  map (foldFactorizationMemoizedBy (ga !) ff primes') [1..n]
  where primes' :: [Int]
        primes' = primes
